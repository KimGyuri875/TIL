--SET operator : UNION, UNION ALL, INTERSECT, MINUS
-- 두개 이상의 쿼리 결과를 하나로 결합시키는 연산자 
-- SELECT 절에 기술하는 컬럼 개수와 데이터 타입은 모든 쿼리에서 동일해야함

--UNION : 중복결과는 한번
SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE
UNION
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY;

--UNION ALL: 중복결과도 다 표시

--INTERSECT : 교집합
SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE
INTERSECT
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY;

--MINUS: 차집합
SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE
MINUS
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY;

-- 데이터개수가 같게하기 위해서 NULL, DUMMY 를 넣어준다
SELECT EMP_NAME, JOB_ID, HIRE_DATE
FROM EMPLOYEE
WHERE DEPT_ID = '20'
UNION
SELECT DEPT_NAME, DEPT_ID, NULL
FROM DEPARTMENT
WHERE DEPT_ID = '20';

--UNION 50번 부서원을 관리자 직원으로 구분하여 표시하고 싶다면?
SELECT  EMP_ID, EMP_NAME, '관리자' AS 구분
FROM    EMPLOYEE
WHERE   MGR_ID IS NULL AND DEPT_ID='50'
UNION
SELECT  EMP_ID, EMP_NAME, '직원' AS 구분
FROM    EMPLOYEE
WHERE   MGR_ID IS NOT NULL AND DEPT_ID='50'
ORDER BY 3;

-- 직급(JOB_TITLE)이 대리 또는 사월 정보를 조회(이름, 직급)
--UNION
SELECT EMP_NAME, JOB_TITLE
FROM EMPLOYEE
JOIN JOB USING(JOB_ID)
WHERE JOB_TITLE = '대리'
UNION
SELECT EMP_NAME, JOB_TITLE
FROM EMPLOYEE
JOIN JOB USING(JOB_ID)
WHERE JOB_TITLE = '사원';

SELECT EMP_NAME, JOB_TITLE
FROM EMPLOYEE
JOIN JOB USING(JOB_ID)
WHERE JOB_TITLE IN ('사원', '대리');

--SUBQUERY
--()로 묶어서 표현, 
-- SELECT ,FROM, WHERE, HAVING 절 등에서 사용가능
-- 단일 행 서브쿼리, 다중 행 서브쿼리 인지를 CHECK 해야한다. 
-- 단일이면 비교연산자도 사용가능, 다중행은 IN, ANY, ALL을 주로 사용한다. 


-- 나승원과 직급(JOB_ID)이 동일하고 나승원보다 급여가 많은 사원의 이름, 직급, 급여를 조회하라
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE JOB_ID = (SELECT JOB_ID
FROM EMPLOYEE
WHERE EMP_NAME='나승원')
AND SALARY > (SELECT SALARY
                FROM EMPLOYEE
                WHERE EMP_NAME='나승원');

-- 최소급여를 받는 사월의 이름, 직급, 급여를 조회

SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MIN(SALARY)
                FROM EMPLOYEE )
                
-- 부서별 급여 총합이 가장 큰 부서의 이름, 급여총합을 조회

SELECT DEPT_NAME, SUM(SALARY)
FROM EMPLOYEE
JOIN DEPARTMENT USING(DEPT_ID)
GROUP BY DEPT_NAME
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY))
                        FROM EMPLOYEE
                        GROUP BY DEPT_ID)
                        
-- IN, NOT IN ,ANY, ALL 연산자들 다중행 서브쿼리에서 사용할 수 있다.
-- NOT IN 의 결과에는 NULL이 포함되어서 안된다. 안그러면 전체를 NULL로 출력한다. 
SELECT EMP_ID, EMP_NAME, '관리자' AS 구분
FROM EMPLOYEE
WHERE EMP_ID IN (SELECT MGR_ID FROM EMPLOYEE)
UNION
SELECT EMP_ID, EMP_NAME, '직원' AS 구분
FROM EMPLOYEE
WHERE EMP_ID NOT IN (SELECT MGR_ID FROM EMPLOYEE WHERE MGR_ID IS NOT NULL)

--위 구현 코드를 다른 방식으로 구현한다면?
SELECT EMP_ID, EMP_NAME, 
    CASE 
        WHEN EMP_ID IN(SELECT MGR_ID FROM EMPLOYEE) THEN '관리자' 
    ELSE '직원' 
    END
FROM EMPLOYEE

SELECT EMP_ID, EMP_NAME, 
    CASE 
        WHEN MGR_ID IS NOT NULL THEN '직원' 
    ELSE '관리자' 
    END AS 구분
FROM EMPLOYEE

-- < ANY : 비교 대상 중 최대 값보다 작음
-- > ANY : 비교 대상 중 최소 값보다 큼
-- = ANY : 연산자와 동일

-- < ALL : 비교 대상 중 최소값 보다 작음
-- > ALL : 비교 대상 중 최대 값 보다 큼

SELECT EMP_NAME, SALARY 
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '대리'
    AND SALARY > ANY ( SELECT SALARY FROM EMPLOYEE JOIN JOB USING(JOB_ID) WHERE JOB_TITLE = '과장')


SELECT EMP_NAME, SALARY 
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '대리'
    AND SALARY > ALL ( SELECT SALARY FROM EMPLOYEE JOIN JOB USING(JOB_ID) WHERE JOB_TITLE = '과장')

--자기 직급의 평균 급여를 받는 직원을 조회하라
SELECT EMP_NAME, JOB_TITLE, SALARY
FROM EMPLOYEE
JOIN JOB USING(JOB_ID)
WHERE (JOB_ID, SALARY) IN (SELECT JOB_ID, TRUNC(AVG(SALARY), -5)
                FROM EMPLOYEE
                GROUP BY JOB_ID)

SELECT JOB_TITLE, TRUNC(AVG(SALARY), -5)
FROM EMPLOYEE
JOIN JOB USING(JOB_ID)
GROUP BY JOB_TITLE

SELECT EMP_NAME, JOB_TITLE, SALARY
FROM (SELECT JOB_ID, TRUNC(AVG(SALARY), -5) AS JOB_AVG
        FROM EMPLOYEE
        GROUP BY JOB_ID) V
JOIN EMPLOYEE E ON(V.JOB_ID = E.JOB_ID AND V.JOB_AVG = E.SALARY)
JOIN JOB J ON(E.JOB_ID = J.JOB_ID)

-- 상관관계 서브쿼리(CORRELATED SUBQUERY)
SELECT EMP_NAME, JOB_TITLE, SALARY
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_ID = J.JOB_ID)
WHERE SALARY = (SELECT TRUNC(AVG(SALARY), -5)
                FROM EMPLOYEE
                WHERE JOB_ID = E.JOB_ID)
        
-- EXISTS, NOT EXISTS
-- EXISTS : 존재하면 TRUE, NOT EXISTS : 존재하지 않으면 TRUE
SELECT EMP_ID, EMP_NAME,'관리자' AS 구분
FROM EMPLOYEE E
WHERE EXISTS (SELECT NULL
                FROM EMPLOYEE
                WHERE E.EMP_ID = MGR_ID)
UNION
SELECT EMP_ID, EMP_NAME, '직원' AS 구분
FROM EMPLOYEE E2
WHERE NOT EXISTS (SELECT NULL
                    FROM EMPLOYEE
                    WHERE E2.EMP_ID = MGR_ID)
ORDER BY 3;

